{"ts":1342095502985,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Observables-JS\n==============\n\nA simple Observer pattern for *your* object model. \n\nInstant Gratification\n---------------------\n\n    var model = {\n      \"location\": { \"lat\": 0, \"lng\": 0  } ,\n      \"heading\": 123,\n      \"target\": { \"lat\": 0, \"lng\": 0 }\n    }\n\n    var _locationObserver = new Observable(\"location\", model);\n    var _headingObserver = new Observable(\"heading\", model);\n    var _targetObserver = new Observable(\"target\", model);\n\n    _locationObserver.addChangeListener(function(newVal, oldVal) {\n      // Wheeee.  We get notifications of changes\n    });\n\n    model.location = { \"lat\": 1, \"lng\": 2 }; \n\nWhy?\n----\n\nI have two major frustrations:\n\n1.   If you want use an \"MVC\" framework,  most of them require that you use\n     their object model.  This frustrates me.  I just want to know when data has changed.\n2.   Listening to changes from multiple async updates and performing actions on these\n     is hard \n\nAPI\n---\n\nObservable - *constructor* \n    new Observable([*required*] propertyName, [*required*] objectToObserve);\n\nObservable - addChangeListener \n    observer.addChangeListener([*required*] function(oldValue, newValue))\n\nGates\n-----\n\nHandling logic based on the state of several independant asynchronus events is \ncumbersome and complex.  The observer pattern allows you to build the systems \nthat are gated on certain conditions being met in your model.\n\n*   OnAnyChange - Fired when any single of the observers notices a change in the\n    data \n\n    OnAnyChange([_locationObserver, _headingObserver, _targetObserver], function() {\n        // Any one of the three observers have changed.\n    });\n\nUnder the hood\n--------------\n\nTo listen to changes to the object, the Observable object changes the\nobserved object by setting up a 'getter' and 'setter'  for the property name\nand caching the value of the actual value.\n\n*Note* tests still need to be don if the property is already a getter or setter.  \n"]],"start1":0,"start2":0,"length1":0,"length2":1930}]],"length":1930}
{"contributors":[],"silentsave":false,"ts":1342095961143,"patch":[[{"diffs":[[-1,"Observables-JS\n==============\n\nA simple Observer pattern for *your* object model. \n\nInstant Gratification\n---------------------\n\n    var model = {\n      \"location\": { \"lat\": 0, \"lng\": 0  } ,\n      \"heading\": 123,\n      \"target\": { \"lat\": 0, \"lng\": 0 }\n    }\n\n    var _locationObserver = new Observable(\"location\", model);\n    var _headingObserver = new Observable(\"heading\", model);\n    var _targetObserver = new Observable(\"target\", model);\n\n    _locationObserver.addChangeListener(function(newVal, oldVal) {\n      // Wheeee.  We get notifications of changes\n    });\n\n    model.location = { \"lat\": 1, \"lng\": 2 }; \n\nWhy?\n----\n\nI have two major frustrations:\n\n1.   If you want use an \"MVC\" framework,  most of them require that you use\n     their object model.  This frustrates me.  I just want to know when data has changed.\n2.   Listening to changes from multiple async updates and performing actions on these\n     is hard \n\nAPI\n---\n\nObservable - *constructor* \n    new Observable([*required*] propertyName, [*required*] objectToObserve);\n\nObservable - addChangeListener \n    observer.addChangeListener([*required*] function(oldValue, newValue))\n\nGates\n-----\n\nHandling logic based on the state of several independant asynchronus events is \ncumbersome and complex.  The observer pattern allows you to build the systems \nthat are gated on certain conditions being met in your model.\n\n*   OnAnyChange - Fired when any single of the observers notices a change in the\n    data \n\n    OnAnyChange([_locationObserver, _headingObserver, _targetObserver], function() {\n        // Any one of the three observers have changed.\n    });\n\nUnder the hood\n--------------\n\nTo listen to changes to the object, the Observable object changes the\nobserved object by setting up a 'getter' and 'setter'  for the property name\nand caching the value of the actual value.\n\n*Note* tests still need to be don if the property is already a getter or setter.  "],[1,"SuperDelegates Foundation Framework\n===================================\n"],[0,"\n"]],"start1":0,"start2":0,"length1":1930,"length2":73}]],"length":73,"saved":false}
{"ts":1342095986200,"patch":[[{"diffs":[[0,"======\n\n"],[1,"SuperDeletages...\n\nUpdated: 12 July 2012\nAuthor: Tom L\n"]],"start1":65,"start2":65,"length1":8,"length2":63}]],"length":128,"saved":false}
{"ts":1342095990998,"patch":[[{"diffs":[[0,"ges...\n\n"],[1,"\n------------------\n"],[0,"Updated:"]],"start1":84,"start2":84,"length1":16,"length2":36}]],"length":148,"saved":false}
{"contributors":[],"silentsave":false,"ts":1342098266944,"patch":[[{"diffs":[[-1,"SuperDelegates Foundation Framework\n===================================\n\nSuperDeletages...\n\n\n------------------\nUpdated: 12 July 2012\nAuthor: Tom L"],[1,"Observables-JS\r\n==============\r\n\r\nA simple Observer pattern for *your* object model. \r\n\r\nInstant Gratification\r\n---------------------\r\n\r\n    var model = {\r\n      \"location\": { \"lat\": 0, \"lng\": 0  } ,\r\n      \"heading\": 123,\r\n      \"target\": { \"lat\": 0, \"lng\": 0 }\r\n    }\r\n\r\n    var _locationObserver = new Observable(\"location\", model);\r\n    var _headingObserver = new Observable(\"heading\", model);\r\n    var _targetObserver = new Observable(\"target\", model);\r\n\r\n    _locationObserver.addChangeListener(function(newVal, oldVal) {\r\n      // Wheeee.  We get notifications of changes\r\n    });\r\n\r\n    model.location = { \"lat\": 1, \"lng\": 2 }; \r\n\r\n    // Inline callback function\r\n    var a = 10;\r\n    var _a_observer = new Observable(\"a\", this, function(newVal){ \r\n      // document.getElementById('value_of_a').innerHTML = newVal;\r\n    });\r\n\r\nWhy?\r\n----\r\n\r\nI have two major frustrations:\r\n\r\n1.   If you want use an \"MVC\" framework,  most of them require that you use\r\n     their object model.  This frustrates me.  I just want to know when data has changed.\r\n2.   Listening to changes from multiple async updates and performing actions on these\r\n     is hard \r\n\r\nAPI\r\n---\r\n\r\nObservable - *constructor* \r\n    new Observable([*required*] propertyName, [*required*] objectToObserve);\r\n\r\nObservable - addChangeListener \r\n    observer.addChangeListener([*required*] function(oldValue, newValue))\r\n\r\nGates\r\n-----\r\n\r\nHandling logic based on the state of several independant asynchronus events is \r\ncumbersome and complex.  The observer pattern allows you to build the systems \r\nthat are gated on certain conditions being met in your model.\r\n\r\n*   OnAnyChange - Fired when any single of the observers notices a change in the\r\n    data \r\n\r\n    OnAnyChange([_locationObserver, _headingObserver, _targetObserver], function() {\r\n        // Any one of the three observers have changed.\r\n    });\r\n\r\nUnder the hood\r\n--------------\r\n\r\nTo listen to changes to the object, the Observable object changes the\r\nobserved object by setting up a 'getter' and 'setter'  for the property name\r\nand caching the value of the actual value.\r\n\r\n*Note* tests still need to be don if the property is already a getter or setter.  \r"],[0,"\n"]],"start1":0,"start2":0,"length1":148,"length2":2192}]],"length":2192,"saved":false}
